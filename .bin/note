#!/usr/bin/env python
# -*- coding: utf-8 -*-

import argparse
import os
from typing import Any
from pprint import pprint
import sys
import logging
import subprocess
from fuzzywuzzy.fuzz import ratio
import re
import glob
import shlex

from prompt_toolkit import prompt
from prompt_toolkit.contrib.completers import WordCompleter




# TODO
#
# A)
# agrep (a non-python dependency ... )
# it might be safer to add fuzzy finding for file finding as well as querying ?
# although it might be very difficult to make it look and work reasonable,
# ideally Unix dependencies such as grep should be avoided,
#
# B)
# list with different formats, add config options when you are certain this
# design patter will work,
#
# C)
# listing, querying and finding notes is limited by the extensions you list **.md
# etc. FIX IT to work for all readable files, including notes that have no
# extension
#
# D) add a universal detailed option for all listing and querying, make it
# reusable, based on file name get details such as size, access time, tags,
# keywords, themes, maybe sentiment score...
#
# LOOK AT TEXTBLOB API (if it changed or improved)
#
# D)
## Write your own debugging tools similar to the `report` method
#
# E)
# At the end add things like tags using textblob and possibly nltk if it's not
# too complicated,
#
# F) TEMPLATES: make template files
#
# G) DO FZF AT THE VERY END !!! because it all needs to work without it, unlike
# coreutills this won't be on every system
#
#

# ##########
# Debugging
# ##########


# logging.basicConfig(
    # level=logging.DEBUG, format='%(levelname)s:%(asctime)s  %(message)s')

logger = logging.getLogger()

####################################################

# THE LOGIC
# ==========
#
# The choosing of a specific mode from
# {edit,find,query,list} stores that mode
#
# It is then checked for and appropriate functions are called
# and variables set.
#
#       I call : edit_handler()
#                find_handler()
#                query_handler()
#                list_handler()
#
#       and they produce the outcome.
#
#  To check that there is a value a function verify_set() is called to check if
#  it is, if not, that function will be turned off.
#
#  Later, if a value is detected, I get variables through a mediator-function
#  that checks in 3 locations:
#
#   In the case of edit
#
#       1. Agrs from the command line (highest weighting)
#       2. Defaults specified in configuration for this specific note format
#       3. Defaults specified in edit / default
#
#   The rest follows a similar pattern.
#
# The `parsers` variable is basicallly a dict of parsers
# this is a way of dealing with lack of namespaces in python
# (as far as I am aware)
#
# `groups` is another dict that helps me to deal with nameing.
#
# ```python
# parsers = {
#   'main': ArgumentParser(),
#   'subparsers: main.add_subparsers(),
#   'edit': subparsers.add_parser('edit'),
#   'query': subparsers.add_parser('query'),
#   'list': subparsers.add_parser('list'),
#   'find': subparsers.add_parser('find')
# }
# ```
#
# naming of `groups` follows this convention:
#
#         ```python
#         groups['edit']['name|format']
#         groups['find']['dirs|all']
#         groups['list']['tree|detailed|concise']
#         ```
#
# A view on `groups`
#
# ```python
# groups = {
#   'edit': {
#       'name|format': {}
#       'location|subject': {}
#   },
#   'query': {
#       'name|format': {}
#       'location|subject': {}
#   },
#   'list': {
#       'name|format': {}
#       'location|subject': {}
#   },
#   'find': {
#       'name|format': {}
#       'location|subject': {}
#   },
#   '*' : {
#       'name|format': {}
#       'location|subject': {}
#   }
# }
# ```

######################
# Configuration Guide
######################
#
# Options:
#
# ## edit
#
#     default:
#
#       - --format : choose from {markdown,rst,asciidoc,textile}
#
#         [DEFAULT is markdown]
#
#         ALIASES  -f
#
#       - --name : the name of new notes to make. Useful, because even if you
#       specify the same not name, your editor will simply reopen that document
#       each time you call for a new note, (good for having a global todo-list).
#
#         [DEFAULT is undefined]
#
#         ALIASES  -n
#
#       - --template : Specify a file to copy to every new note. Paritcularly
#       useful when defining that separately for each format. [DEFAULT is False]
#
#       - --location : the global location of all notes
#         [DEFAULT is ~/Notes]
#
# => format-specific:
#   - template :
#                either specify True to use a deafult template, [bool]
#                or
#                specify a file to use it as a template [str]
#
#     It will be copied to new notes.
#
#   - location : the format-specific location for notes [str]
#
#     #synonyms:
#     detailed == long == l [keywords, line count, date, location etc]
#     regular == normal == concise == r [title, date]
#     tree == structure == hierarchy == t [title, location(dir)]
#
#   - name : the default name of the note [str]
#
#          eg note.md
#
# --------------------------------------------------------------
#
# ## find [SEARCH TERM 1] [[SEARCH TERM 2] ... ]
#
#    NOTE based on titles, not content.
#
#     --fzf : [True|False] [bool]
#     --no-fzf : [True|False [bool]
#
#     --all : search in the dirs recursively starting from
#             the default note location for new note creation
#     --dirs : [DIR1] [[DIR2] [DIR3] ... ] [list[str]]
#              list of dirs to scan when looking for notes
#
#     --fuzzy : [True|False] [bool]
#               If you want fuzzy finding of notes
#     --exact, --no-fuzzy : [True|False] [bool]
#
# --------------------------------------------------------------
#
# ## query
#
#       recursively grep through note content to match queries
#
#   --dirs, -d : [DIR1] [[DIR2] [DIR3] ... ] [list[str]]
#                list of of dirs to look for when grepping
#   --all      : search in the dirs recursively starting from
#                the default note location for new note creation
#
# --------------------------------------------------------------
#
# ## LIST
#
#   - format : the usual lising format of notes you want [str]
#
#           choose 1 from {detailed,regular,tree} [str]
#
# --------------------------------------------------------------

# Set variables
#
parsers = {
    'main': {},
    'edit': {},
    'analyse': {},
    'list': {},
    'find': {},
    'query': {},
    'todo': {},
    '*': {}
}

groups = {
    'main': {'verbosity'},
    'edit': {},
    'analyse': {},
    'list': {'regular': {}, 'tree': {}, 'stats': {}},
    'find': {},
    'query': {},
    'todo': {},
    '*': {}
}

parsers['main'] = argparse.ArgumentParser(
    prog="note",
    description="Note management tool. \n\
    edit, manage, search for, query, and lexically analyse your notes.",
    epilog="\nThanks for using the software.\n")

parsers['main'].add_argument(
    '--location',
    default='~/Notes',
    help='Global location where notes are stored and managed. \
    DEFAULT : %(default)s')

parsers['subparsers'] = parsers['main'].add_subparsers(dest='mode')

###########################
# ANALYSE
###########################

parsers['analyse'] = parsers['subparsers'].add_parser('analyse')

###########################
# QUERY
###########################

parsers['query'] = parsers['subparsers'].add_parser('query')


###########################
# edit
###########################

parsers['edit'] = parsers['subparsers'].add_parser('edit')

parsers['edit'].add_argument(
    "name",
    help="The name of your new note. \n\
    The app will infer the format from extension.\n \
    PLEASE provide it.",
    metavar='NAME')

groups['edit']['template'] = parsers['edit'].add_mutually_exclusive_group()

groups['edit']['template'].add_argument(
    "-t",
    "--template",
    help="The template to use for your new note.\n\
    [DEFAULT is %(default)s]",
    metavar='ABS PATH TO TEMPLATE FILE',
    default=False,
    nargs='?')

groups['edit']['template'].add_argument(
    "--no-template",
    dest='template',
    help=
    "You don't want a template as the basis for a new note [DEFAULT is %(default)s]",
    action='store_false')

parsers['edit'].add_argument(
    "-s",
    "--subject",
    "--subdir",
    dest='subject',
    help="Subject of the note. NOTE it will edit a subdir \
    (with that subject's name) in the default note location",
    nargs='?')

commands = [
    'analyse', 'edit', 'find', 'query', 'list', 'todo', '--absolute',
    '--basename', '--fuzzy', '--fzf', '--lines', '--no-fuzzy', '--relative',
    '--subject', '--tree', '--template'
]

markdown_notes = glob.glob(os.path.join(os.path.expanduser('~/Notes/'),'**.md'),recursive=True)
textile_notes = glob.glob(os.path.join(os.path.expanduser('~/Notes/'),'**.textile'),recursive=True)
rst_notes = glob.glob(os.path.join(os.path.expanduser('~/Notes/'),'**.rst'),recursive=True)
asciidoc_notes = glob.glob(os.path.join(os.path.expanduser('~/Notes/'),'**.asciidoc'),recursive=True)
all_notes = markdown_notes + rst_notes + asciidoc_notes + textile_notes
completer = WordCompleter(commands + [os.path.basename(i) for i in all_notes])

args = prompt(' note >> ', completer=completer)
args = parsers['main'].parse_args(shlex.split(args))

location = os.path.abspath(os.path.expanduser(os.path.expandvars(args.location)))

def report(item: Any, length_of_var=True, type_of_var=True, pprint_var=True):
    if pprint_var:
        pprint(item)
        if length_of_var:
            try:
                print("length : {}".format(len(item)))
            except:  # throws an Exception if that item has no len
                print("length : ??? ")
                if type_of_var:
                    try:
                        print("type : {}".format(type(item)))
                        print("\n")
                    except:
                        print("type : ??? ")
                        print("\n")


def edit_handler():
    logger.info('note absolute dir : ' + location)
    note_name = args.name
    logger.info('note name : ' + note_name)
    if args.subject:
        subject = args.subject
        logger.info('subject : ' + subject)
        note_path = os.path.join(location, subject, note_name)
    else:
        note_path = os.path.join(location, note_name)
    logger.info('note absolute path : ' + note_path)
    editor = os.path.expandvars('${EDITOR}')
    logger.info('editor identified : ' + editor)
    if not os.path.exists(note_path):
        logger.info('the note doesn\'t exist yet, it will be editd.')
        if  args.template:
            template_path = os.path.abspath(
                os.path.expandvars(os.path.expanduser(args.template)))
            logger.info('template absolute path : ' + note_path)
            assert os.path.exists(
                template_path), 'Specified template doesn\' exist.'
            logger.info('template file found in ' + template_path +
                        " copying as a new file")
            subprocess.run(['cp', template_path, note_path])
        else:
            subprocess.run([
                'mkdir', '-p', os.path.dirname(note_path)
            ])  # call for mkdir with a safe -p flag just in case
            os.mknod(note_path)
    logger.info('opening the note `' + note_name + '` in `' + editor + "`")
    subprocess.run([editor, note_path])


def query_handler():
    for term in args.terms:
        subprocess.run([
            'grep', '-PIHn', '--line-buffered', "--exclude-dir='.[cC]ache'",
            "--exclude-dir='*dicts*'", "--exclude-dir='.git'",
            "--exclude-dir='timeshift'", "--exclude-dir='Trash'",
            "--exclude-dir='*chrome*'", "--exclude-dir='.pyenv'", term] + all_notes)

def todo_handler():
    #report(args)
    # report(args.mode)
    subprocess.run([os.path.expandvars('${EDITOR}'), args.todo])


def analyse_handler():
    # report(args.mode)
    pass


def main():
    if args.mode == 'edit':
        edit_handler()
    elif args.mode == 'find':
        find_handler()
    elif args.mode == 'query':
        query_handler()
    elif args.mode == 'list':
        list_handler()
    elif args.mode is 'todo':
        todo_handler()


if __name__ == "__main__":
    main()

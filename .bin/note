#!/usr/bin/env python
# -*- coding: utf-8 -*-

import argparse
import os
from typing import Any
from pprint import pprint
import sys
import logging
import subprocess
import shlex
import re
import glob
from prompt_toolkit import prompt
from prompt_toolkit.contrib.completers import WordCompleter
from PythonUtils.debugging import report

logging.basicConfig(
    level=logging.DEBUG, format='%(levelname)s:%(asctime)s  %(message)s')

logger = logging.getLogger()

def list_notes():
    # extension_whitelist = ['md', 'txt', 'textile', 'rst', 'html', 'tex']
    os.chdir(os.path.abspath(os.path.expanduser('~/Notes')))
    all_files = glob.glob(os.path.join('.', '**'), recursive=True)
    filtered = filter(
        lambda x: os.path.isfile(x) and re.
        compile('(\.(md)|(tex)|(txt)|(org)|(textile)|(rst)|(html))$').search(x),
        all_files)
    as_list = list(filtered)
    return [re.compile('^\./').sub("", i) for i in as_list]


# Set variables
parsers = {
    'main': {},
    'edit': {},
    'list': {},
    'query': {},
}

groups = {
    'main': {},
    'edit': {},
    'list': {},
    'query': {},
}

parsers['main'] = argparse.ArgumentParser(
    prog="note",
    description="Note management tool. \n\
    edit, manage, search for, query, and lexically analyse your notes."
                                                                       ,
    epilog="\nThanks for using the software.\n")

parsers['main'].add_argument(
    '--location',
    default='~/Notes',
    help='Global location where notes are stored and managed. \
    DEFAULT : %(default)s'
                          )

parsers['subparsers'] = parsers['main'].add_subparsers(dest='mode')

###########################
# LIST
###########################

parsers['list'] = parsers['subparsers'].add_parser('list')

groups['list']['format'] = parsers['list'].add_mutually_exclusive_group()

groups['list']['format'].add_argument(
    '-l',
    '-list',
    action='store_const',
    const='list',
    dest='format',
    default='list',
    help='Long, detailed format of note listing\n [DEFAULT is %(default)s]')

groups['list']['format'].add_argument(
    '-t',
    '--tree',
    '--structure',
    '--hierarchy',
    action='store_const',
    const='tree',
    dest='format',
    default=[],
    help='Tree format notes of listing')

###########################
# QUERY
###########################

parsers['query'] = parsers['subparsers'].add_parser('query')

parsers['query'].add_argument(
    'terms',
    nargs='+',
    metavar='SEARCH TERM',
    help='When querying the content of notes look for these strings.')

groups['query']['lines|files'] = parsers['query'].add_mutually_exclusive_group()

groups['query']['lines|files'].add_argument(
    '-l',
    '--lines',
    action='store_const',
    dest='format',
    help='Standard grep behaviour, show matching lines.',
    default='lines',
    const='lines')

groups['query']['lines|files'].add_argument(
    '-n',
    '--files',
    '--notes',
    '--matching-notes',
    '--matching-files',
    dest='format',
    action='store_const',
    help='Show notes with matches. [DEFAULT is %(default)s]',
    const='files')

###########################
# edit
###########################

parsers['edit'] = parsers['subparsers'].add_parser('edit')

parsers['edit'].add_argument(
    "name",
    help="The name of your new note. \n\
    The app will infer the format from extension.\n \
    PLEASE provide it."
                       ,
    metavar='NAME')

groups['edit']['template'] = parsers['edit'].add_mutually_exclusive_group()

groups['edit']['template'].add_argument(
    "-t",
    "--template",
    help="The template to use for your new note.\n\
    [DEFAULT is %(default)s]"
                             ,
    metavar='ABS PATH TO TEMPLATE FILE',
    default='~/.templates/template.rst',
    nargs='?')

groups['edit']['template'].add_argument(
    "--no-template",
    dest='template',
    help=
    "You don't want a template as the basis for a new note [DEFAULT is %(default)s]",
    action='store_false')


if len(sys.argv) == 1: # for interactive usage

    commands = ['edit', 'query', 'list']

    print('\nWelcome to the interactive note creation wizard!')
    print(
        '\nMany sane defaults are defined so you only need to provide a [new] file name.'
    )
    print('\nchoices :: edit query todo\n')

    # initiliase
    mode_arg = prompt(' note >> ', completer=WordCompleter(commands))

    if mode_arg == "edit":
        edit_commands = ['--template', '--no-template']
        notes = list_notes()
        completer = WordCompleter(notes + edit_commands)
        mode = 'edit'

    elif mode_arg == "query":
        query_commands = ['--lines', '--files']
        completer = WordCompleter(query_commands)
        mode = 'query'

    elif mode_arg == "list":
        list_commands = ['--tree', '--list']
        completer = WordCompleter(list_commands)
        mode = 'list'

        # if more than one args provided and
        # if any of the args provided is a commands

    elif any(map(lambda x : x in commands, shlex.split(mode_arg))) and len(shlex.split(mode_arg)) > 1:
        report(mode_arg)
        mode = mode_arg
        completer = WordCompleter(commands + list_notes())
        # mode = mode_arg

    else:
        subprocess.run([os.path.abspath(sys.argv[0]), '-h'])
        sys.exit()

    # initiliase
    args = mode

    # iterate unitll enter is pressed
    new_arg = None

    while new_arg != "":
        print('')  # new line
        new_arg = prompt(' note ' + args + ' >> ', completer=completer)
        if new_arg not in args:
            #if new_arg in command and not any(map(lambda argument : argument in commands, args)):
            args += " " + new_arg
        completer = WordCompleter(  # completer get passed on with modified values on each loop
            list(filter(lambda x: x not in shlex.split(args), completer.words)))
        # it removes typed words (included already in args) from completion

    report(args)
    report(shlex.split(args))
    args = parsers['main'].parse_args(shlex.split(args))

else:  # if not running interactively

    args = parsers['main'].parse_args()

# ###########################################################################
# PARSIGN COMPLETE
#
# parsed variables
note_dir = os.path.abspath(
    os.path.expanduser(os.path.expandvars(args.location)))
# automatically change dir to note dir and operate relative to that dir
# automatically change dir to note dir and operate relative to that dir
os.chdir(note_dir)

# ###########################################################################
# HANDLERS

def edit_handler():
    logger.info('note absolute dir : ' + note_dir)
    note_name = args.name
    logger.info('note name : ' + note_name)
    note_path = os.path.join(note_dir, note_name)
    logger.info('note absolute path : ' + note_path)
    editor = os.path.expandvars('${EDITOR}')
    logger.info('editor identified : ' + editor)
    if not os.path.exists(note_path):
        logger.info('the note doesn\'t exist yet, it will be editd.')
        if args.template:
            template_path = os.path.abspath(
                os.path.expandvars(os.path.expanduser(args.template)))
            logger.info('template absolute path : ' + note_path)
            assert os.path.exists(
                template_path), 'Specified template doesn\' exist.'
            logger.info('template file found in ' + template_path +
                        " copying as a new file")
            subprocess.run(['cp', template_path, note_path])
        else:
            subprocess.run([
                'mkdir', '-p', os.path.dirname(note_path)
            ])  # call for mkdir with a safe -p flag just in case
            os.mknod(note_path)
    logger.info('opening the note `' + note_name + '` in `' + editor + "`")
    subprocess.run([editor, note_path])


def query_handler():
    if args.format == 'lines':
        flags = '-PIHn'
    elif args.format == 'files':
        flags = '-l'
    for term in args.terms:
        subprocess.run(['grep', flags, '--line-buffered', term] + list(
            filter(
                lambda x: os.path.isfile(x) and re.compile('(\.(md)|(tex)|(txt)|(org)|(textile)|(rst)|(html))$').search(x),
                glob.glob(os.path.join(note_dir, '**'), recursive=True))))


def list_handler():
    if args.format == 'list':
        for note in list_notes():
            pprint(note)
    elif args.format == 'tree':
        subprocess.run(['tree', '--prune', '-I', '*.ppt*', note_dir])


def main():
    if args.mode == 'edit':
        edit_handler()
    elif args.mode == 'query':
        query_handler()
    elif args.mode == 'list':
        list_handler()


if __name__ == "__main__":
    main()

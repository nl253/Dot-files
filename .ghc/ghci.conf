-- vim:ft=haskell:
:set prompt "\n ghci Î» "
:set prompt-cont " block >> "
:set +m
:def hoogle (\str -> return $ ":! hoogle --count=15 " ++ show str)
:def haskell_files (\str -> return ":! find -name '*.hs'")
:def vim (\str -> return (":! $EDITOR " ++ str ))

:module + Data.Semigroup Data.Ratio System.Directory Data.Bifunctor Data.Bitraversable  Data.Ix System.Exit Debug.Trace System.Environment Data.Maybe Data.Tuple Data.Function Data.Either Data.Foldable Text.Show.Functions Data.Word System.FilePath

putStrLn ""

import Control.Applicative (liftA, liftA2, liftA3, (<**>), (<*>), ZipList, empty, Alternative, (<|>))
import qualified Control.Category ((<<<))
import Control.Exception (catch)
import Control.Exception (try, tryJust)
import Control.Monad ((<=<), void, mzero, forM, forM_, liftM, liftM2, liftM3, foldM, mfilter)
import Data.Functor.Bind (liftF2, liftF3, join)
import Data.Int (Int8, Int16, Int32, Int64)  
import Data.List ( (\\) , delete , deleteFirstsBy , dropWhileEnd , elemIndices , elemIndex , find , genericDrop , genericIndex , genericLength , genericReplicate , genericSplitAt , genericTake , group , inits , intersectBy , insert , intercalate , intersect , intersperse , isInfixOf , isPrefixOf , isSubsequenceOf , isSuffixOf , mapAccumL , mapAccumR , maximumBy , minimumBy , nub , nubBy , partition , permutations , sort , sortBy , sortOn , stripPrefix , subsequences , tails , transpose , uncons , unfoldr , union , unionBy )
import Data.Monoid (mempty, mconcat)
import Data.Traversable (for)
import System.IO hiding (readFile, writeFile, appendFile)
import Control.Monad.Zip (mzip, mzipWith, munzip)
import System.IO.Error (tryIOError)
import System.Process (runCommand, env, cwd, runInteractiveCommand, spawnCommand)
import System.Random (getStdGen, mkStdGen, random, randomRs)

-- UTF-8
import qualified Data.ByteString as BS
import qualified Data.ByteString.Lazy as BL
import qualified Data.ByteString.Char8 as C
import qualified Data.ByteString.Lazy.Char8 as CL

-- UNICODE
{-import qualified Data.Text as T-}
{-import qualified Data.Text.Lazy as TL-}
{-import qualified Data.Text.IO as TIO-}
{-import qualified Data.Text.Lazy.IO as TLIO-}

import qualified Text.Parsec as Parsec

import Text.Printf (printf)
import Data.Char hiding (ClosePunctuation, ConnectorPunctuation, Control, CurrencySymbol, DashPunctuation, DecimalNumber, EnclosingMark, FinalQuote, Format, GeneralCategory, InitialQuote, LetterNumber, LineSeparator, LowercaseLetter, MathSymbol, ModifierLetter, ModifierSymbol, NonSpacingMark, NotAssigned, OpenPunctuation, OtherLetter, OtherNumber, OtherPunctuation, OtherSymbol, ParagraphSeparator, PrivateUse, Space, SpacingCombiningMark, Surrogate, TitlecaseLetter, UppercaseLetter)

putStrLn " -- Imports --"

:show imports

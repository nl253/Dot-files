-- vim:ft=haskell:
:set prompt "\n ghci Î» "
:set prompt-cont " block >> "
:set +m
:def hoogle (\str -> return $ ":! hoogle --count=15 " ++ show str)
:def haskell_files (\str -> return ":! find -name '*.hs'")
:def vim (\str -> return (":! $EDITOR " ++ str ))

:module + Data.Semigroup Data.Ratio System.Directory Data.Bifunctor Data.Bitraversable  Data.Ix System.Exit Debug.Trace System.Environment Data.Maybe Data.Tuple Data.Function Data.Either Data.Foldable Text.Show.Functions Data.Word System.FilePath

putStrLn ""

import Data.Monoid (mempty, mconcat)
import System.Random (getStdGen, mkStdGen, random, randomRs)
import System.Process (runCommand, env, cwd, runInteractiveCommand, spawnCommand)
import Control.Monad (forM, join, forM_, liftM, liftM2, liftM3, foldM, mfilter)
import Control.Applicative (liftA, liftA2, liftA3, (<**>), (<*>), ZipList)
import System.IO hiding (readFile, writeFile, appendFile)
import Data.List ( (\\) , delete , deleteFirstsBy , dropWhileEnd , elemIndices , elemIndex , find , genericDrop , genericIndex , genericLength , genericReplicate , genericSplitAt , genericTake , group , inits , intersectBy , insert , intercalate , intersect , intersperse , isInfixOf , isPrefixOf , isSubsequenceOf , isSuffixOf , mapAccumL , mapAccumR , maximumBy , minimumBy , nub , nubBy , partition , permutations , sort , sortBy , sortOn , stripPrefix , subsequences , tails , transpose , uncons , unfoldr , union , unionBy )
import Data.Traversable (for)

import qualified Data.ByteString.Lazy as LBS
import qualified Data.ByteString as BS
import qualified Text.Parsec as Parsec

import Text.Printf (printf)
import Data.Char hiding (GeneralCategory)

putStrLn " -- Imports --"

:show imports

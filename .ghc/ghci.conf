-- vim:ft=haskell:
:set prompt "\n ghci Î» "
:set prompt-cont " block >> "
:set +m
:def hoogle (\str -> return (concat [":! hoogle --count=15 \"", str, "\""]))
{- :def ghc_pkg (\str-> return (concat [":!", GHC.Paths.ghc_pkg, " ", str])) -}
:def haskell_files (\str -> return ":! find -name '*.hs'")
:def vim (\str -> return (":! $EDITOR " ++ str ))

{- let users_guide p = doc ("/users_guide" ++ if null p then "/index.html" else p) -}
{- :def users_guide users_guide -}

{- let { redir varcmd = case break Data.Char.isSpace varcmd of { (var,_:cmd) -> return $ unlines [":set -fno-print-bind-result","tmp <- System.Directory.getTemporaryDirectory","(f,h) <- System.IO.openTempFile tmp \"ghci\"","sto <- GHC.Handle.hDuplicate System.IO.stdout","GHC.Handle.hDuplicateTo h System.IO.stdout","System.IO.hClose h",cmd,"GHC.Handle.hDuplicateTo sto System.IO.stdout","let readFileNow f = readFile f >>= \\t->length t `seq` return t",var++" <- readFileNow f","System.Directory.removeFile f"]; _ -> return "putStrLn \"usage: :redir <var> <cmd>\"" } } -}
{- :def redir redir -}
 
-- Integration with the hlint code style tool
{- let hlint _ = return $ unlines [":set -w",    ":redir hlintvar1 :show modules", ":cmd return (\":! hlint \" ++ (concat $ Data.List.intersperse \" \" (map (fst . break (==',') . drop 2 . snd . break (== '(')) $ lines hlintvar1)))",    ":set -Wall"] -}
{- :def hlint hlint -}

:module + Data.Ratio Data.Bifunctor Data.Bitraversable Data.Ix System.Exit Debug.Trace System.Environment Data.Maybe Data.Tuple Data.Function Data.Either Data.Foldable Text.Show.Functions Data.Word
putStrLn ""
import Text.Printf (printf)
import Data.Char hiding (GeneralCategory)
import qualified Data.ByteString.Lazy as LBS
import qualified Data.ByteString as BS
import qualified Text.Parsec as Parsec
import Control.Monad (forM, join, forM_)
import System.IO hiding (readFile, writeFile, appendFile)
import Data.List ( (\\) , delete , deleteFirstsBy , dropWhileEnd , elemIndices , elemIndex , find , genericDrop , genericIndex , genericLength , genericReplicate , genericSplitAt , genericTake , group , inits , intersectBy , insert , intercalate , intersect , intersperse , isInfixOf , isPrefixOf , isSubsequenceOf , isSuffixOf , mapAccumL , mapAccumR , maximumBy , minimumBy , nub , nubBy , partition , permutations , sort , sortBy , sortOn , stripPrefix , subsequences , tails , transpose , uncons , unfoldr , union , unionBy )
putStrLn " -- Imports --"
:show imports
